<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Isometric Structure</title>
    <style>

        body {
    margin: 0;
    overflow: hidden;
    background-color: #fbcce1;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

html {
    overflow: hidden;
}
        #ui-overlay {
            position: absolute;
            pointer-events: none;
            color: #555;
            text-shadow: 1px 1px 0px rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.95);
        }

        .btn-group {
            pointer-events: all;
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 15px;
        }

        button {
            padding: 12px 20px;
            border: 2px solid #FFD1DC;
            background: linear-gradient(135deg, #FEF9C3 0%, #FFD1DC 100%);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            color: #944E63;
            text-align: center;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(255, 209, 220, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #FFD1DC 0%, #E0BBE4 100%);
            border-color: #E0BBE4;
            box-shadow: 0 6px 20px rgba(255, 209, 220, 0.5);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(255, 209, 220, 0.3);
        }

        button.active {
            background: linear-gradient(135deg, #A1E3F9 0%, #B2F2BB 100%);
            border-color: #A1E3F9;
            color: #366B6B;
            box-shadow: 0 6px 20px rgba(161, 227, 249, 0.4);
        }

        #status {
            font-size: 11px;
            color: #888;
            margin-bottom: 10px;
            font-weight: 500;
        }

        #ui-overlay h2 {
            margin: 0 0 5px 0;
            color: #944E63;
        }

        #ui-overlay p {
            margin: 10px 0 0 0;
            color: #888;
        }

        /* Desktop/Laptop - Left side */
        @media (min-width: 1024px) {
            #ui-overlay {
                top: 20px;
                left: 20px;
                width: auto;
                max-width: 320px;
            }

            #ui-overlay h2 {
                font-size: 24px;
            }

            .btn-group button {
                padding: 14px 24px;
                font-size: 14px;
            }
        }

        /* Tablet - Center bottom */
        @media (min-width: 768px) and (max-width: 1023px) {
            #ui-overlay {
                bottom: 40px;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                width: 90%;
                max-width: 500px;
            }

            #ui-overlay h2 {
                font-size: 20px;
            }

            .btn-group button {
                padding: 12px 20px;
                font-size: 13px;
            }
        }

        /* Mobile - Center bottom */
        @media (max-width: 767px) {
            #ui-overlay {
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                width: 85%;
                max-width: 300px;
                padding: 15px;
            }

            #ui-overlay h2 {
                font-size: 16px;
            }

            #ui-overlay p {
                font-size: 9px;
            }

            .btn-group button {
                padding: 10px 16px;
                font-size: 12px;
            }
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>


    <div id="ui-overlay">
        <h2 style="margin:0; font-size: 18px;">Do you want to be my Valentine?</h2>
        <div id="status">Loading assets...</div>
        <div class="btn-group">
            <button id="btn1" onclick="switchCharacter(1)">Definitely Yes</button>
            <button id="btn2" onclick="switchCharacter(2)">Maybe No</button>
        </div>
        <p style="font-size: 11px; color: #888; margin-top: 15px;">
            <a href="plans.html" style="color:#555">skip</a>
        </p>
    </div>

    <!-- Updated CDN links based on your request -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Variables from your script



        //////////////////////////////////////////////////////////////////////////
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#fbcce1');
        scene.fog = new THREE.FogExp2('#d1f2f2', 0.04);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(1.5, 1.5, 1.5);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        const clock = new THREE.Clock();

        // --- PHASE 2: LIGHTING & STRUCTURED FLOOR ---
        const hemiLight = new THREE.HemisphereLight('#A1E3F9', '#fbcce1', .9);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight('#ffffff', 2.5);
        dirLight.position.set(1, 1, 1);
        //dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // Toon Shading Gradient Map
        const colors = new Uint8Array([0, 128, 255]);
        const gradientMap = new THREE.DataTexture(colors, colors.length, 1, THREE.RedFormat);
        gradientMap.needsUpdate = true;

        // Structured Floor
        const floorSize = 100;
        const floorGeom = new THREE.PlaneGeometry(floorSize, floorSize, 50, 50);
        const floorMat = new THREE.MeshToonMaterial({
            color: '#fdfdfd',
            gradientMap: gradientMap,
            side: THREE.DoubleSide
        });

        const floor = new THREE.Mesh(floorGeom, floorMat);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const grid = new THREE.GridHelper(floorSize, 40, '#fbcce1', '#e0f7fa');
        grid.position.y = 0.01;
        scene.add(grid);

        // --- PHASE 3: SCATTERED GEOMETRY (Torus & Hearts) ---
        const objects = [];
        const pastelPalette = ['#B2F2BB', '#A1E3F9', '#FEF9C3', '#FFD1DC', '#E0BBE4'];

        // Heart Shape Path
        const x = 0, y = 0;
        const heartShape = new THREE.Shape();
        heartShape.moveTo(x + 0.5, y + 0.5);
        heartShape.bezierCurveTo(x + 0.5, y + 0.5, x + 0.4, y, x, y);
        heartShape.bezierCurveTo(x - 0.6, y, x - 0.6, y + 0.7, x - 0.6, y + 0.7);
        heartShape.bezierCurveTo(x - 0.6, y + 1.1, x - 0.3, y + 1.54, x + 0.5, y + 1.9);
        heartShape.bezierCurveTo(x + 1.2, y + 1.54, x + 1.6, y + 1.1, x + 1.6, y + 0.7);
        heartShape.bezierCurveTo(x + 1.6, y + 0.7, x + 1.6, y, x + 1, y);
        heartShape.bezierCurveTo(x + 0.7, y, x + 0.5, y + 0.5, x + 0.5, y + 0.5);

        const heartGeom = new THREE.ExtrudeGeometry(heartShape, {
            depth: 0.4,
            bevelEnabled: true,
            bevelThickness: 0.1,
            bevelSize: 0.1
        });
        heartGeom.center();
        heartGeom.scale(0.9, 0.9, 0.9);

        const torusGeom = new THREE.TorusGeometry(0.6, 0.2, 8, 100);

        for (let i = 0; i < 60; i++) {
            const isHeart = Math.random() > 0.4; // 60% chance for hearts, 40% for torus
            const material = new THREE.MeshToonMaterial({
                color: pastelPalette[Math.floor(Math.random() * pastelPalette.length)],
                gradientMap: gradientMap
            });

            const mesh = new THREE.Mesh(isHeart ? heartGeom : torusGeom, material);

            const range = 20;
            mesh.position.set(
                (Math.random() - 0.5) * range,
                Math.random() * 1.5 + 0.5,
                (Math.random() - 0.5) * range
            );

            mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            mesh.scale.setScalar(Math.random() * 0.4 + 0.6);

            mesh.userData = {
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                floatOffset: Math.random() * Math.PI * 2,
                floatSpeed: 0.5 + Math.random() * 0.5
            };

            scene.add(mesh);
            objects.push(mesh);
        }
        //////////////////////////////////////////////////////////////////////////
        let characterModel = null;
        let characterModel1 = null;
        let characterModel2 = null;

        let mixer1 = null;
        let mixer2 = null;
        let mixer3 = null;

        //let viewSize = 3;

        function init() {
            // 1. Scene Setup

            // 5. Structure Creation (Your Wheat material settings)
            structure = new THREE.Group();
            scene.add(structure);
            // 6. Loading sequence (Refactored for non-module GLTFLoader)
            const loader = new THREE.GLTFLoader();

            // Load first model
            loader.load(
                'models/animated_rigged_1.glb',
                function (gltf) {
                    characterModel = gltf.scene;
                    characterModel.position.set(0, 0.1, 0);
                    characterModel.scale.set(1, 1, 1);
                    characterModel.rotation.y += .75;
                    characterModel.traverse(n => { if (n.isMesh) n.castShadow = true; });
                    structure.add(characterModel);

                    if (gltf.animations && gltf.animations.length) {
                        mixer1 = new THREE.AnimationMixer(characterModel);
                        mixer1.clipAction(gltf.animations[0]).play();
                    }

                    document.getElementById('status').innerText = "Model 1 Loaded";
                    document.getElementById('btn1').classList.add('active');
                }
            );

            // Load second model
            loader.load(
                'models/twerk.glb',
                function (gltf) {
                    characterModel1 = gltf.scene;
                    characterModel1.position.set(0, 0.1, 0);
                    characterModel1.scale.set(1, 1, 1);
                    characterModel1.rotation.y += .75;
                    characterModel1.traverse(n => { if (n.isMesh) n.castShadow = true; });

                    characterModel1.visible = false;
                    structure.add(characterModel1);

                    if (gltf.animations && gltf.animations.length) {
                        mixer2 = new THREE.AnimationMixer(characterModel1);
                        mixer2.clipAction(gltf.animations[0]).play();
                    }

                    document.getElementById('status').innerText = "All Characters Ready";
                }
            );
            loader.load('models/rejection.glb', (gltf) => {
                characterModel2 = gltf.scene;
                characterModel2.traverse(n => {
                    if (n.isMesh) {
                        n.castShadow = true;
                        n.receiveShadow = true;
                    }
                });
                characterModel2.position.set(0, 0.1, 0);
                characterModel2.scale.set(1, 1, 1);
                characterModel2.rotation.y += .75;

                characterModel2.visible = false;
                scene.add(characterModel2);

                mixer3 = new THREE.AnimationMixer(characterModel2);
                if (gltf.animations && gltf.animations.length) {
                    mixer3.clipAction(gltf.animations[0]).play();
                }

                document.getElementById('status').innerText = 'Ready';
            }, undefined, (err) => {
                console.error('Error loading no character:', err);
            });



            animate();
        }


        function switchCharacter(id) {
            if (!characterModel || !characterModel1 || !characterModel2) return;

            if (id === 1) {
                characterModel.visible = false;
                characterModel1.visible = true;
                characterModel2.visible = false;
                document.getElementById('btn-yes').classList.add('active');
                document.getElementById('btn-no').classList.remove('active');
            } else if (id === 2) {
                characterModel.visible = false;
                characterModel1.visible = false;
                characterModel2.visible = true;
                document.getElementById('btn-no').classList.add('active');
                document.getElementById('btn-yes').classList.remove('active');
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            elapsedTime = clock.getElapsedTime();

            // Update scattered objects
            objects.forEach((obj) => {
                obj.rotation.y += obj.userData.rotationSpeed;
                obj.rotation.z += obj.userData.rotationSpeed * 0.5;
                obj.position.y = (1.5 + Math.sin(elapsedTime * obj.userData.floatSpeed + obj.userData.floatOffset)) * 1.2;
            });
            const delta = 1 / 100;
            if (characterModel && characterModel.visible && mixer1) mixer1.update(delta);
            if (characterModel1 && characterModel1.visible && mixer2) mixer2.update(delta);
            if (characterModel2 && characterModel2.visible && mixer3) mixer3.update(delta);

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>